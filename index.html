<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Audio Visualizer based on Three.js</title>
  <link href="https://fonts.googleapis.com/css?family=Saira" rel="stylesheet">
  <link rel="stylesheet" href="./style.css">
</head>
<body>
  <div id="header">
    <h1>MULTIMOD | MrGato y sus putas 2</h1>
  </div>
  <div id="right">
    <h2>DISCORD OFICIAL:</h2>
    <h3><a href="https://discord.gg/49BxqscV" target="_blank">https://discord.gg/49BxqscV</a></h3>
  </div>
  <div id="content">
    <label for="thefile" class="file" style="display: none;"> Choose an audio file
      <input type="file" id="thefile" accept="audio/*" style="display: none;" />
    </label>
    <select id="preloaded-audio" style="display: none;">
      <option value="">Select a song</option>
      <option value="audio/donki.mp3">Song 1</option>
      <option value="audio/kaskade.mp3">Song 2</option>
      <option value="audio/twofriends.mp3">Song 3</option>
    </select>
    <audio id="audio" controls style="display: none;"></audio>
    <div id="out"></div>
    <div id="anim" style="width: 1px; height: 1px; position: absolute; top: 0; left: 0; background-color: red;"></div>
  </div>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js'></script>
  <script src='https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.3/dat.gui.min.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.3.0/simplex-noise.min.js'></script>
  <script src="./script.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
        const audio = document.getElementById('audio');
        const preloadedAudio = document.getElementById('preloaded-audio');
        let context;
        let src;
        let analyser;

        function getRandomSong() {
            const options = Array.from(preloadedAudio.options);
            const validOptions = options.filter(option => option.value !== "");
            const randomIndex = Math.floor(Math.random() * validOptions.length);
            return validOptions[randomIndex].value;
        }

        function playAudio(src) {
            audio.src = src;
            audio.load();
            audio.play().then(() => {
                if (!context) {
                    context = new AudioContext();
                    src = context.createMediaElementSource(audio);
                    analyser = context.createAnalyser();
                    src.connect(analyser);
                    analyser.connect(context.destination);
                    analyser.fftSize = 512;
                    play();
                }
            }).catch(error => {
                console.error('Error playing audio:', error);
            });
        }

        function initAudio() {
            const randomSong = getRandomSong();
            if (randomSong) {
                playAudio(randomSong);
            }
        }

        function attemptAudioContextResume() {
            if (context && context.state === 'suspended') {
                context.resume().then(() => {
                    console.log('AudioContext resumed');
                }).catch(error => {
                    console.error('Error resuming AudioContext:', error);
                });
            }
        }

        function animate() {
            document.getElementById('anim').style.transform = `scale(${1 + Math.sin(Date.now() / 1000) * 0.1})`;
            attemptAudioContextResume();
            requestAnimationFrame(animate);
        }

        // Inicia la animaci√≥n y el intento de reanudar el contexto de audio
        initAudio();
        animate();

        function play() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const scene = new THREE.Scene();
            const group = new THREE.Group();
            const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 100);
            camera.lookAt(scene.position);
            scene.add(camera);

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            const planeGeometry = new THREE.PlaneGeometry(800, 800, 20, 20);
            const planeMaterial = new THREE.MeshLambertMaterial({
                color: 0x6904ce,
                side: THREE.DoubleSide,
                wireframe: true
            });

            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -0.5 * Math.PI;
            plane.position.set(0, 30, 0);
            group.add(plane);

            const plane2 = new THREE.Mesh(planeGeometry, planeMaterial);
            plane2.rotation.x = -0.5 * Math.PI;
            plane2.position.set(0, -30, 0);
            group.add(plane2);

            const icosahedronGeometry = new THREE.IcosahedronGeometry(10, 4);
            const lambertMaterial = new THREE.MeshLambertMaterial({
                color: 0xff00ee,
                wireframe: true
            });

            const ball = new THREE.Mesh(icosahedronGeometry, lambertMaterial);
            ball.position.set(0, 0, 0);
            group.add(ball);

            const ambientLight = new THREE.AmbientLight(0xaaaaaa);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffffff);
            spotLight.intensity = 0.9;
            spotLight.position.set(-10, 40, 20);
            spotLight.lookAt(ball);
            spotLight.castShadow = true;
            scene.add(spotLight);

            scene.add(group);

            document.getElementById('out').appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize, false);

            render();

            function render() {
                analyser.getByteFrequencyData(dataArray);

                const lowerHalfArray = dataArray.slice(0, (dataArray.length / 2) - 1);
                const upperHalfArray = dataArray.slice((dataArray.length / 2) - 1, dataArray.length - 1);

                const overallAvg = avg(dataArray);
                const lowerMax = max(lowerHalfArray);
                const lowerAvg = avg(lowerHalfArray);
                const upperMax = max(upperHalfArray);
                const upperAvg = avg(upperHalfArray);

                const lowerMaxFr = lowerMax / lowerHalfArray.length;
                const lowerAvgFr = lowerAvg / lowerHalfArray.length;
                const upperMaxFr = upperMax / upperHalfArray.length;
                const upperAvgFr = upperAvg / upperHalfArray.length;

                makeRoughGround(plane, modulate(upperAvgFr, 0, 1, 0.5, 4));
                makeRoughGround(plane2, modulate(lowerMaxFr, 0, 1, 0.5, 4));

                makeRoughBall(ball, modulate(Math.pow(lowerMaxFr, 0.8), 0, 1, 0, 8), modulate(upperAvgFr, 0, 1, 0, 4));

                group.rotation.y += 0.005;
                renderer.render(scene, camera);
                requestAnimationFrame(render);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function makeRoughBall(mesh, bassFr, treFr) {
                mesh.geometry.vertices.forEach(function(vertex) {
                    const offset = mesh.geometry.parameters.radius;
                    const amp = 7;
                    const time = window.performance.now();
                    vertex.normalize();
                    const rf = 0.00001;
                    const distance = (offset + bassFr) + noise.noise3D(vertex.x + time * rf * 7, vertex.y + time * rf * 8, vertex.z + time * rf * 9) * amp * treFr;
                    vertex.multiplyScalar(distance);
                });
                mesh.geometry.verticesNeedUpdate = true;
                mesh.geometry.normalsNeedUpdate = true;
                mesh.geometry.computeVertexNormals();
                mesh.geometry.computeFaceNormals();
            }

            function makeRoughGround(mesh, distortionFr) {
                mesh.geometry.vertices.forEach(function(vertex) {
                    const amp = 2;
                    const time = Date.now();
                    const distance = (noise.noise2D(vertex.x + time * 0.0003, vertex.y + time * 0.0001) + 0) * distortionFr * amp;
                    vertex.z = distance;
                });
                mesh.geometry.verticesNeedUpdate = true;
                mesh.geometry.normalsNeedUpdate = true;
                mesh.geometry.computeVertexNormals();
                mesh.geometry.computeFaceNormals();
            }

            function fractionate(val, minVal, maxVal) {
                return (val - minVal) / (maxVal - minVal);
            }

            function modulate(val, minVal, maxVal, outMin, outMax) {
                const fr = fractionate(val, minVal, maxVal);
                const delta = outMax - outMin;
                return outMin + (fr * delta);
            }

            function avg(arr) {
                const total = arr.reduce(function(sum, b) {
                    return sum + b;
                });
                return (total / arr.length);
            }

            function max(arr) {
                return arr.reduce(function(a, b) {
                    return Math.max(a, b);
                });
            }
        }

        vizInit();
    });
  </script>
</body>
</html>
